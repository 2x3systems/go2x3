syntax = "proto3";
package graph;

//option go_package = "github.com/2x3systems/go2x3/lib2x3/graph";



enum TracesSign {
    TracesSign_Zero = 0;
    TracesSign_Pos  = 1;
    TracesSign_Neg  = 2;
}


message CatalogState {

    int32               MajorVers                   = 1;
    int32               MinorVers                   = 2;
    
    // TraceCount is the Traces len for this Catalog's Traces index.
    // This effectively sets a vertex size limit for Graphs this Catalog can process.
    // DefaultCatalogTraceCount specifies the default TraceCount for new catalogs. 
    int32               TraceCount                  = 10;
                
    // NumTraces[Nv] is the number of traces of in this catalog for a given number of vertices.
    // Note: NumTraces[0] is always 0 and len(NumTraces) == TraceCount+1
    repeated uint64     NumTraces                   = 11;
    
    // NumPrimes[Nv] is the number of particle primes for a given number of vertices.
    // Note: NumPrimes[0] is always 0 and len(NumPrimes) == TraceCount+1
    repeated uint64     NumPrimes                   = 12;
    
    // Set if this catalog is to auto-determine if a newly added Graph / Traces are primes.
    bool                IsPrimeCatalog              = 20;
}


// IsPrime specifies if a graph system has constituent factors or not.
// If a graph is prime, then it cannot be formed by combining any other particles.
enum IsPrime {
    IsPrime_Unspecified = 0;
    IsPrime_Yes         = 1;
    IsPrime_No          = 2;
}


// GraphDef is a particular vertex+edge assignment with bound names.
// Has similarities to a "Contributing structure" in quantum|chemistry lingo. https://en.wikipedia.org/wiki/Resonance_(chemistry)
message GraphDef {

    IsPrime             IsPrime                     = 1;
                
    // If non-zero, the Traces of this graph has a registered ID. 
    // These values can be used to lookup a graph's common ascii symbolic name, UTF8 symbolic name, or nickname
    uint64              TracesID                    = 2;
    uint64              GraphID                     = 3;
                
    // A specific vertex+edge assignment 
    bytes               GraphEncoding               = 8;
                
                    // Graph expr string that canonically express this graph and can therefore be used for easy graph equivalence testing.
    string              CanonicGraphExpr            = 9;
   
    // Any number of graph expr strings that reduce to the same equivalent (canonic) graph.
    // This list is stored and maintained in sorted UTF8 order for binary search.
    repeated string     GraphExprs                  = 12;
    
}

// GroupID is a vertex group ID containing one or more Vtx.
enum GroupID {
    GroupID_void      = 0;
    GroupID_LoopVtx   = 1; // Group self-edge having cycle length 1 
    GroupID_LoopGroup = 2; // Group self-edge having cycle length 2
    GroupID_G1        = 3; // Ordinal of first vertex group
}

// VtxStatus specifies the current state of Vtx that comprise a 2x3 graph.
enum VtxStatus {
    
    // The graph is an in unassigned or otherwise invalid state
    VtxStatus_Invalid = 0;
     
    // All Vtx have been validated as expressing a valid and complete graph.
    // VtxID, E_FromVtx. E_Sign have been assigned.
    // Each Vtx is in its own separate group and has exactly 3 VtxEdges.
    VtxStatus_Validated = 2;
    
    // First, edges are sorted by DstVtxID then SrcVtxID.
    // Next, edges that have matching DstVtxID and SrcVtxID are combined (summed).
    VtxStatus_Normalized  = 4;
    
    // A cycle spectrum is performed on the graph to canonically order vtx groups.
    // Vtx determined to be in the same group are merged into a single vtx group.
    // Finally, all edges are normalized. 
    VtxStatus_Canonized = 6;
}


/*
enum EdgeType {
	EdgeType_Nil          = 0;
	EdgeType_Loop         = 1;
	EdgeType_Single       = 2;
	EdgeType_Double       = 3;
	EdgeType_Triple       = 4;
}


enum EdgeDomain {
    EdgeDomain_EvenOdd = 0;
    EdgeDomain_Odd     = 1;
    EdgeDomain_Even    = 2;
}
*/

// VtxEdge is characterized by the Src and Dst VtxID and C1 and C2.
// Identities that can transform one VtxEdge into another VtxEdge can be used in a process 
//    called normalization where edge signs and degree are rotated to a canonical form.
//
// Working hypothesis:  any valid 2x3 graph expressed as a set of VtxEdges since normalizations of C1 and C2 
//     are enough on their own to uniquely identify a graph.  Since the graph is known to exist and be a valid construction,.
//     by the given set ensures that C1 and C2 *alone* are enough to represent the graph (and thus reconstruct it if need be).
message VtxEdge {
    
    // Initially assigned label: 1, 2, 3,..  (a one-based index ID)
    uint32              DstVtxID = 1;
    
    // Specifies the remote vertex of this edge (a one-based vtx index ID)
    uint32              SrcVtxID = 3;
    
    // Number of instances of Traces
    int32               CountPos  = 4; // number of instances of []Traces
    int32               CountNeg  = 5; // number of instances of -[]Traces

    //int64               MetricNumerator   = 8; // numerator of the metric
    //int64               MetricDenominator = 9; // numerator of the metric
    
    // TracesID is a unique ID associated with the normalized []Cycles integer vector.
    // We could carry the odd and even Traces components separately inline, but this is more compact and efficient.
    // TracesID == 0 is hardwired to [0,0,0,..], and occurs in many particles (e.g. TracesID_Even for bosons is 0) 
    uint64              TracesID = 11; 
    
    // If non-zero, the Traces of this graph is prime and has a registered ID.
    //uint64              PrimeID = 12;
    
    // Cycles is an integer vector corresponding to the number of cycles of each "Ci" length.
    repeated int64      Cycles         = 19;
    

}





// VtxGroup generally aren't used for Graph serialization but is used to model runtime processing and state 
message VtxGroup {

    // Number of total Vtx instances in this group
    uint32              VtxCount                    = 1;
    
    // Initially assigned label: 1, 2, 3, ..  (a one-based index ID)
    //uint32              VtxID                       = 2;

    // Group ID assignment of home Vtx based on canonic cycle vector comparison ordering.
    // 0 denotes unassigned; first valid GroupID is 1.
    uint32              GroupID                     = 3;
    
    // VtxEdge             EdgeA                  = 4;
    // VtxEdge             EdgeB                  = 4;
    // VtxEdge             EdgeC                  = 4;
    
    // When assigned from a 2x3 graph, each Vtx has 3 edges. 
    // After canonization, the edges of vertices having the same Cycles are consolidated into corresponding groups.
    repeated VtxEdge    Edges                       = 5;
    
    // The product of this times VtxCount is the this groups total contribution to VtxGraph.Traces
    repeated int64      Cycles                      = 10;
}

message Tag {
    string              Label                      = 1;
    string              TagURI                     = 2;
    string              Expr                       = 3;
}

message VtxGraph {
    VtxStatus           Status                      = 1;
    
    repeated Tag        Tags                        = 2;

    repeated VtxEdge    Edges                      = 3;
}


